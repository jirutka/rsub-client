#!/usr/bin/env python

import getopt
import logging
import os
import socket
import sys
from contextlib import contextmanager
from logging import DEBUG, INFO, StreamHandler
from os import W_OK
from os.path import isfile

if sys.version_info >= (3, 0):
    from configparser import ConfigParser, NoOptionError, NoSectionError
    from io import StringIO
else:
    from ConfigParser import ConfigParser, NoOptionError, NoSectionError
    from StringIO import StringIO

DATE = '2014-08-18'
VERSION = '1.0.0'
VERSION_STRING = 'rmate version %s (%s)' % (DATE, VERSION)

log = logging.getLogger(__name__)


@contextmanager
def atomic_write(filepath):
    """ Writeable file object that atomically updates a file.

    :param filepath: path of the file to be opened for writing (in binary mode)
    """
    tmppath = filepath + '~'
    while isfile(tmppath):
        tmppath += '~'
    try:
        with open(tmppath, 'wb') as file:
            yield file
        os.rename(tmppath, filepath)
    finally:
        try:
            os.remove(tmppath)
        except EnvironmentError:
            pass


class ConnectionError(Exception):

    def __init__(self, msg, cause=None):
        self.msg = msg
        self.cause = cause

    def __str__(self):
        return self.msg


class Settings:
    def __init__(self):
        self.host = 'localhost'
        self.port = 52698
        self.wait = False
        self.force = False
        self.verbose = False
        self.lines = []
        self.names = []
        self.types = []
        self.files = []

        self.read_disk_settings()

        # Environment settings
        self.host = os.getenv('RMATE_HOST', self.host)
        self.port = os.getenv('RMATE_PORT', self.port)

        self.parse_cli_options()

        if self.host == 'auto' and os.environ.get('SSH_CONNECTION') is not None:
            self.host = os.getenv('SSH_CONNECTION', 'localhost').split(' ')[0]

    def usage(self):
        print("usage: %s [OPTION]... FILE...\n\n"
              "      --host HOST  Connect to HOST. Use 'auto' to detect the host from\n"
              "                   SSH. Defaults to %s\n"
              "  -p, --port PORT  Port number to use for connection. Defaults to %d\n"
              "  -w, --[no-]wait  Wait for file to be closed by TextMate\n"
              "  -l, --line LINE  Place carat on line LINE after loading the file.\n"
              "                   TextMate selection strings can be used\n"
              "  -m, --name NAME  The display name shown in TextMate\n"
              "  -t, --type TYPE  Treat file as having TYPE\n"
              "  -f, --force      Open even if the file is not wratable\n"
              "  -v, --verbose    Verbose logging messages\n"
              "  -h, --help       Show this help and exit\n"
              "      --version    Show version and exit\n\n"
              "When FILE is -, read standard input.\n"
              % (sys.argv[0], self.host, self.port))

    def read_disk_settings(self):
        config = SectionLessConfigParser()
        try:
            config.read('/etc/rmate.rc', os.path.expanduser('~/.rmate.rc'))
        except:
            log.debug("Could not read settings from disk.")
        self.host = config['host'] or self.host
        self.port = int(config['port'] or self.port)

    def parse_cli_options(self):
        try:
            optlist, args = getopt.gnu_getopt(sys.argv[1:], 'hp:wl:m:t:fv', [
                'host=', 'port=', 'wait', 'no-wait', 'line=', 'name=',
                'type=', 'force', 'verbose', 'help', 'version'])
        except getopt.GetoptError:
            self.usage()
            sys.exit(2)

        for name, value in optlist:
            if name == '--version':           print(VERSION_STRING); sys.exit()
            elif name in ('-h', '--help'):    self.usage(); sys.exit()
            elif name == '--host':            self.host = value
            elif name in ('-p', '--port'):    self.port = int(value)
            elif name in ('-w', '--wait'):    self.wait = True
            elif name == '--no-wait':         self.wait = False
            elif name in ('-l', '--line'):    self.lines.append(value)
            elif name in ('-m', '--name'):    self.names.append(value)
            elif name in ('-t', '--type'):    self.types.append(value)
            elif name in ('-f', '--force'):   self.force = True
            elif name in ('-v', '--verbose'): self.verbose = True

        if '-' in sys.argv[1:] and '-' not in args:
            args.append('-')
        self.files = args


class SectionLessConfigParser(ConfigParser):

    """ ConfigParser for reading config files without sections. """

    FAKE_SECTION = 'NOSECTION'

    def read(self, *filenames):
        """ Override superclass method to read & parse file(s) without section.

        This implementation is quite a hack, it just inserts fake section at
        the beginning of the file object being parsed.
        """
        read_ok = []
        for filename in filenames:
            try:
                with open(filename) as f:
                    fp = StringIO("[%s]\n%s" % (self.FAKE_SECTION, f.read()))
                    self._read(fp, filename)
            except EnvironmentError:
                continue
            read_ok.append(filename)

        return read_ok

    def __getitem__(self, option):
        """ Get an option value for the default section. """
        try:
            return self.get(self.FAKE_SECTION, option)
        except (NoOptionError, NoSectionError):
            return None


class FileInfo(object):

    """ This class represents a file to be opened in the remote editor. """

    def __init__(self, data, filepath=None):
        self.data = data
        self.file_path = filepath
        self.display_name = "%s:%s" % (socket.gethostname(), filepath or "untitled (stdin)")
        self.file_type = None
        self.line_num = None

    @staticmethod
    def from_stdin():
        """ Read data from the stdin and return FileInfo object. """

        log.info("Reading from stdin, press ^D to stop")
        return FileInfo(sys.stdin.read().encode('utf8'))

    @staticmethod
    def from_file(filepath):
        """ Create FileInfo object from the file path.

        If path of an existing file is given, then it reads the file. Otherwise
        the file will be created during first save.
        """
        data = b''
        if isfile(filepath):
            with open(filepath, 'rb') as f:
                data = f.read()
        return FileInfo(data, filepath)

    def variables(self):
        """ Return a dict of variables as specified in rmate. """
        dic = {
            'display-name': self.display_name,
            'file-type': self.file_type,
            'real-path': os.path.abspath(self.file_path) if self.file_path else None,
            'selection': self.line_num or None,
            'token': self.file_path or '-',
            # to be compatible with TextMate
            'data-on-save': 'yes',
            're-activate': 'yes'
        }
        return {k: v for k, v in dic.items() if v is not None}.items()


class RemoteEditorClient(object):

    def __init__(self, host, port):
        """ Initialize connection with a remote editor.

        :param host: IP address or domain name of the remote editor
        :param port: port number that the remote editor listens on
        :raises ConnectionError: if failed to connect to the editor
        """
        try:
            self._socket = socket.create_connection((host, port))
            self._rfile = self._socket.makefile('rb')
            self._wfile = self._socket.makefile('wb')
        except EnvironmentError as e:
            raise ConnectionError("Could not connect to editor!", e)

        server_hello = next(self._readlines())
        if not server_hello:
            self.close()
            raise ConnectionError("No response from editor!")

        log.debug("Connected to: %s", server_hello)

    def send_files(self, files):
        """ Open files in the remote editor.

        :param files: list of :class:`FileInfo` instances
        """
        send = self._send

        for file in files:
            send("open\n")
            for name, value in file.variables():
                send("%s: %s\n" % (name, value))
            send("data: %d\n" % len(file.data))
            if file.data != b'':
                send(file.data)
            send("\n")
        send(".\n")
        self._wfile.flush()

    def listen(self):
        """ Start listening on the socket for commands from the editor.

        This method is blocking; it finish when the socket is closed.
        """
        for line in self._readlines():
            if line == 'save':
                self._handle_save()
            elif line == 'close':
                self._handle_close()
            else:
                log.debug("Unknown command: %s", line)
        self.close()

    def close(self):
        """ Close the socket and all the opened file objects. """

        log.debug("Closing connection...")
        if self._wfile:
            self._wfile.close()
        if self._rfile:
            self._rfile.close()
        try:
            self._socket.shutdown(socket.SHUT_RDWR)
            self._socket.close()
        except EnvironmentError:
            pass
        self._socket = None

    def _handle_save(self):
        """ Handle *save* command; write received file. """

        variables, data = self._read_response()
        path = variables['token']
        
        log.debug("Received update: %s", path)
        try:
            with atomic_write(path) as f:
                f.write(data)
        except EnvironmentError:
            log.debug("Failed to write file: %s", path)

    def _handle_close(self):
        """ Handle *close* command; just log it. """
        variables, data = self._read_response()
        path = variables['token']
        log.debug("Closed: %s", path)

    def _read_response(self):
        """ Return tuple of variables and data read from the socket. """

        variables = {}
        data = b""

        for line in self._readlines():
            if line == "":
                break
            name, value = (s.strip() for s in line.split(":", 1))
            if name == 'data':
                data += self._rfile.read(int(value))
            else:
                variables[name] = value

        return (variables, data)

    def _send(self, data):
        """ Write data to the socket.

        :param data: bytes or string (will be encoded as UTF-8)
        """
        if not isinstance(data, bytes):
            data = data.encode('utf8')
        self._wfile.write(data)

    def _readlines(self):
        """ Read lines from the socket.

        :returns: generator that reads line by line from the socket, decodes
                  lines as UTF-8 and strips white spaces
        """
        return (line.decode('utf8').strip() for line in self._rfile)


## MAIN ##

settings = Settings()

log.setLevel(DEBUG if settings.verbose else INFO)
log.addHandler(StreamHandler())

files = []
for idx, path in enumerate(settings.files):
    if path == '-' and sys.stdin.isatty():
        file = FileInfo.from_stdin()
    elif os.path.isdir(path):
        log.warning("'%s' is a directory!", path)
        continue
    else:
        if isfile(path) and not os.access(path, W_OK):
            if settings.force:
                log.debug("File %s is not writable. Opening anyway.", path)
            else:
                log.warning("File %s is not writable! Use -f/--force to open anyway.", path)
                continue
        file = FileInfo.from_file(path)

    if len(settings.names) > idx:
        file.display_name = settings.names[idx]
    if len(settings.types) > idx:
        file.file_type = settings.types[idx]
    if len(settings.lines) > idx:
        file.line_num = settings.lines[idx]

    files.append(file)

try:
    client = RemoteEditorClient(settings.host, settings.port)
    client.send_files(files)

    if not settings.wait and os.fork():
        sys.exit()

    client.listen()

except ConnectionError as e:
    log.error(e.msg)
