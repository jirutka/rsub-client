#!/usr/bin/env python

import getopt
import logging
import os
import socket
import sys
import shutil
from logging import DEBUG, INFO, StreamHandler
from os import W_OK
from os.path import isfile
from socket import AF_INET, SOCK_STREAM

if sys.version_info >= (3, 0):
    from configparser import ConfigParser, NoOptionError, NoSectionError
    from io import StringIO
else:
    from ConfigParser import ConfigParser, NoOptionError, NoSectionError
    from StringIO import StringIO

DATE = '2014-08-18'
VERSION = '1.0.0'
VERSION_STRING = 'rmate version %s (%s)' % (DATE, VERSION)

log = logging.getLogger(__name__)


def enc(string):
    if sys.version_info >= (3, 0):
        return bytes(string, 'utf-8')
    else:
        return string


def dec(byte_string):
    if sys.version_info >= (3, 0):
        return str(byte_string, 'utf-8')
    else:
        return byte_string


def handle_save(variables, data):
    path = variables['token']
    try:
        log.debug("Saving %s", path)
        backup_path = '%s~' % path
        while isfile(backup_path):
            backup_path = '%s~' % backup_path
        if isfile(path):
            shutil.copy2(path, backup_path)
        file = open(path, 'wb')
        file.write(data)
        if isfile(backup_path):
            os.remove(backup_path)
    except (IOError, OSError):
        log.debug("Save failed!")


def handle_close(variables):
    path = variables['token']
    log.debug("Closed %s", path)


def handle_cmd(textmate, cmd):
    variables = {}
    data = enc('')
    for line in textmate:
        line = dec(line)
        if line.strip() == "":
            break
        s = line.split(': ', 2)
        name = s[0].strip()
        value = s[1].strip()
        variables[name] = value
        if name == 'data':
            data += textmate.read(int(value))

    if 'data' in variables:
        del variables['data']
    if cmd == 'save':
        handle_save(variables, data)
    elif cmd == 'close':
        handle_close(variables)


def connect_to_tm():
    try:
        socket.setdefaulttimeout(5)
        textmate_sock = socket.socket(AF_INET, SOCK_STREAM)
        textmate_sock.connect((settings.host, settings.port))
        textmate_sock.setblocking(True)
        textmate = textmate_sock.makefile('rwb')
    except socket.error:
        log.error("Error connecting to TextMate!")
        exit(1)

    server_info = dec(textmate.readline())

    if server_info.strip() == "":
        log.error("Couldn't connect to TextMate!")
        exit(1)

    log.debug("Connect: %s", server_info)

    return textmate


def handle_cmds(textmate, cmds):
    if len(cmds) == 0:
        return

    for cmd in cmds:
        cmd.send(textmate)
    textmate.write(enc('.\n'))

    textmate.flush()
    for command in textmate:
        handle_cmd(textmate, dec(command).strip())
    textmate.close()
    log.debug("Done.")


class Settings:
    def __init__(self):
        self.host = 'localhost'
        self.port = 52698
        self.wait = False
        self.force = False
        self.verbose = False
        self.lines = []
        self.names = []
        self.types = []
        self.files = []

        self.read_disk_settings()

        # Environment settings
        self.host = os.getenv('RMATE_HOST', self.host)
        self.port = os.getenv('RMATE_PORT', self.port)

        self.parse_cli_options()

        if self.host == 'auto' and os.environ.get('SSH_CONNECTION') is not None:
            self.host = os.getenv('SSH_CONNECTION', 'localhost').split(' ')[0]

    def usage(self):
        print("usage: %s [OPTION]... FILE...\n\n"
              "      --host HOST  Connect to HOST. Use 'auto' to detect the host from\n"
              "                   SSH. Defaults to %s\n"
              "  -p, --port PORT  Port number to use for connection. Defaults to %d\n"
              "  -w, --[no-]wait  Wait for file to be closed by TextMate\n"
              "  -l, --line LINE  Place carat on line LINE after loading the file.\n"
              "                   TextMate selection strings can be used\n"
              "  -m, --name NAME  The display name shown in TextMate\n"
              "  -t, --type TYPE  Treat file as having TYPE\n"
              "  -f, --force      Open even if the file is not wratable\n"
              "  -v, --verbose    Verbose logging messages\n"
              "  -h, --help       Show this help and exit\n"
              "      --version    Show version and exit\n\n"
              "When FILE is -, read standard input.\n"
              % (sys.argv[0], self.host, self.port))

    def read_disk_settings(self):
        config = SectionLessConfigParser()
        try:
            config.read('/etc/rmate.rc', os.path.expanduser('~/.rmate.rc'))
        except:
            log.debug("Could not read settings from disk.")
        self.host = config['host'] or self.host
        self.port = int(config['port'] or self.port)

    def parse_cli_options(self):
        try:
            optlist, args = getopt.gnu_getopt(sys.argv[1:], 'hp:wl:m:t:fv', [
                'host=', 'port=', 'wait', 'no-wait', 'line=', 'name=',
                'type=', 'force', 'verbose', 'help', 'version'])
        except getopt.GetoptError:
            self.usage()
            sys.exit(2)

        for name, value in optlist:
            if name == '--version':           print(VERSION_STRING); sys.exit()
            elif name in ('-h', '--help'):    self.usage(); sys.exit()
            elif name == '--host':            self.host = value
            elif name in ('-p', '--port'):    self.port = int(value)
            elif name in ('-w', '--wait'):    self.wait = True
            elif name == '--no-wait':         self.wait = False
            elif name in ('-l', '--line'):    self.lines.append(value)
            elif name in ('-m', '--name'):    self.names.append(value)
            elif name in ('-t', '--type'):    self.types.append(value)
            elif name in ('-f', '--force'):   self.force = True
            elif name in ('-v', '--verbose'): self.verbose = True

        if '-' in sys.argv[1:] and '-' not in args:
            args.append('-')
        self.files = args


class SectionLessConfigParser(ConfigParser):

    """ ConfigParser for reading config files without sections. """

    FAKE_SECTION = 'NOSECTION'

    def read(self, *filenames):
        """ Override superclass method to read & parse file(s) without section.

        This implementation is quite a hack, it just inserts fake section at
        the beginning of the file object being parsed.
        """
        read_ok = []
        for filename in filenames:
            try:
                with open(filename) as f:
                    fp = StringIO("[%s]\n%s" % (self.FAKE_SECTION, f.read()))
                    self._read(fp, filename)
            except EnvironmentError:
                continue
            read_ok.append(filename)

        return read_ok

    def __getitem__(self, option):
        """ Get an option value for the default section. """
        try:
            return self.get(self.FAKE_SECTION, option)
        except (NoOptionError, NoSectionError):
            return None


class Command:
    def __init__(self, command):
        self.command = command
        self.variables = {}
        self.data = None
        self.size = None

    def __setitem__(self, index, value):
        self.variables[index] = value

    def read_stdin(self):
        self.data = enc(sys.stdin.read())
        self.size = len(self.data)

    def read_file(self, path):
        with open(path, 'rb') as f:
            self.data = f.read()
            self.size = f.tell()

    def send(self, textmate):
        textmate.write(enc(self.command + '\n'))
        for name in self.variables.keys():
            value = self.variables[name]
            textmate.write(enc('%s: %s\n' % (name, value)))
        if self.data is not None:
            textmate.write(enc('data: %d\n' % self.size))
            textmate.write(self.data)
        textmate.write(enc('\n'))

## MAIN ##

settings = Settings()

log.setLevel(DEBUG if settings.verbose else INFO)
log.addHandler(StreamHandler())

cmds = []
for idx, path in enumerate(settings.files):
    if path == '-' and sys.stdin.isatty():
        log.info("Reading from stdin, press ^D to stop")
    elif os.path.isdir(path):
        log.warning("'%s' is a directory!", path)
        continue
    elif isfile(path) and not os.access(path, W_OK):
        if settings.force:
            log.debug("File %s is not writable. Opening anyway.", path)
        else:
            log.warning("File %s is not writable! Use -f/--force to open anyway.", path)
            continue

    cmd = Command("open")
    if len(settings.names) > idx:
        cmd['display-name'] = settings.names[idx]
    elif path == '-':
        cmd['display-name'] = '%s:untitled (stdin)' % socket.gethostname()
    else:
        cmd['display-name'] = '%s:%s' % (socket.gethostname(), path)
    if len(settings.types) > idx:
        cmd['file-type'] = settings.types[idx]
    elif path == '-':
        cmd['file-type'] = 'txt'
    if path != '-':
        cmd['real-path'] = os.path.abspath(path)
    if len(settings.lines) > idx:
        cmd['selection'] = settings.lines[idx]

    cmd["data-on-save"] = 'yes'
    cmd["re-activate"] = 'yes'
    cmd["token"] = path
    if path == '-':
        cmd.read_stdin()
    elif isfile(path):
        cmd.read_file(path)
    else:
        cmd['data'] = "0"
    cmds.append(cmd)

s = connect_to_tm()

if not settings.wait and os.fork():
    sys.exit()

handle_cmds(s, cmds)
